#include <REGX52.H>

void Timer0_Init()//初始化定时器和中断系统//1毫秒  //1毫秒@11.0592MHz
{
	TMOD &= 0xF0;		//设置定时器模式
	TMOD |= 0x01;		//设置定时器模式
	TL0 = 0x66;		//设置定时初值
	TH0 = 0xFC;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
	ET0 = 1; //允许中断
	EA = 1;
	PT0 = 0;//PT0分为1,0；1高优先级,0低优先级，多个中断才会有优先级的区别

//	//	TMOD = 0x01;//0000 0001，四位设置一个定时器的模式，后四位的后两位设置为01表示两个字节（分为高八位和低八位）都使用，也就是说可以计数到65535
//	//与或式配置，替换上一句代码，目的是为了不影响高四位，配置低四位
//	TMOD = TMOD&0xF0;//把TMOD低四位清零，高四位不变
//	TMOD = TMOD|0x01;//把TMOD的最低位置1，其余位不变，
//	//配置TCON
//	TF0 = 0;//TF设置为0；避免产生中断，
//	TR0 = 1;//定时器开始
//	//从64535开始计时到65535，也就是1000us = 1ms；
//	TH0= 64535/256; //高八位赋值给TH0 （65435 与65535 差1000,1us计数器加一，1000us也就是1ms）//定时1毫秒
//	TL0 = 645535 % 256;//低八位
//	//中断部分配置
//	ET0 = 1;
//	EA = 1;
//	PT0 = 0;//PT0分为1,0；1高优先级,0低优先级，多个中断才会有优先级的区别
}

/*
1秒模板
void Tmer0_Routine() interrupt 1  //中断函数  interrupt 1是T0的中断号
{
	static unsigned int T0Count = 0;
	//进入这个函数说明已经计数到65525了，两个字节数字位1111111111111111，也就是65535，需要重新从64535开始
	TH0= 0xFC;//定时初值
	TL0 = 0x66;
	T0Count++;
	if(T0Count++ >= 1000)
	{
		T0Count = 0;
	}
}
*/